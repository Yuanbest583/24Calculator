<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>24Calculator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .calculator {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .input-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .number-input {
            width: 60px;
            height: 60px;
            font-size: 24px;
            text-align: center;
            border: 2px solid #ddd;
            border-radius: 4px;
        }
        .number-input:focus {
            border-color: #4CAF50;
            outline: none;
        }
        .calculate-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .calculate-btn:hover {
            background-color: #45a049;
        }
        .result-container {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 100px;
            background-color: #f9f9f9;
        }
        .result-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .solution {
            margin-bottom: 8px;
            padding: 8px;
            background-color: #e8f5e9;
            border-radius: 4px;
        }
        .no-solution {
            color: #f44336;
            font-style: italic;
        }
        .error {
            color: #f44336;
            margin-bottom: 10px;
        }
        .stats {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>24Calculator</h1>
    <div class="calculator">
        <div class="input-container">
            <input type="number" class="number-input" min="1" max="13" placeholder="">
            <input type="number" class="number-input" min="1" max="13" placeholder="">
            <input type="number" class="number-input" min="1" max="13" placeholder="">
            <input type="number" class="number-input" min="1" max="13" placeholder="">
            <button class="calculate-btn">计算</button>
        </div>
        <div class="error" id="error-message"></div>
        <div class="result-container">
            <div class="result-title">计算结果：</div>
            <div id="result-content"></div>
            <div class="stats" id="stats"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const inputs = document.querySelectorAll('.number-input');
            const calculateBtn = document.querySelector('.calculate-btn');
            const resultContent = document.getElementById('result-content');
            const errorMessage = document.getElementById('error-message');
            const statsElement = document.getElementById('stats');
            
            calculateBtn.addEventListener('click', calculate24);
            
            inputs.forEach(input => {
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        calculate24();
                    }
                });
            });
            
            function calculate24() {
                errorMessage.textContent = '';
                resultContent.innerHTML = '';
                statsElement.textContent = '';
                
                const numbers = [];
                let isValid = true;
                
                inputs.forEach(input => {
                    const num = parseInt(input.value);
                    if (isNaN(num) || num < 1 || num > 13) {
                        isValid = false;
                        input.style.borderColor = '#f44336';
                    } else {
                        numbers.push(num);
                        input.style.borderColor = '#ddd';
                    }
                });
                
                if (!isValid) {
                    errorMessage.textContent = '请输入1-13之间的有效数字！';
                    return;
                }
                
                const startTime = performance.now();
                const solutions = solve24(numbers);
                const endTime = performance.now();
                const timeTaken = (endTime - startTime).toFixed(2);
                
                if (solutions.length === 0) {
                    resultContent.innerHTML = '<div class="no-solution">没有找到可行的方案。</div>';
                } else {
                    solutions.forEach(solution => {
                        const div = document.createElement('div');
                        div.className = 'solution';
                        div.textContent = solution;
                        resultContent.appendChild(div);
                    });
                }
                
                statsElement.textContent = `共找到 ${solutions.length} 个唯一解，耗时 ${timeTaken} 毫秒`;
            }
            
            function solve24(numbers) {
                const solutions = new Set();
                const ops = ['+', '-', '*', '/'];
                const seen = new Set();
                
                function permute(arr, temp = []) {
                    if (arr.length === 0) {
                        for (let i = 0; i < 4; i++) {
                            for (let j = 0; j < 4; j++) {
                                for (let k = 0; k < 4; k++) {
                                    const expressions = [
                                        `((${temp[0]}${ops[i]}${temp[1]})${ops[j]}${temp[2]})${ops[k]}${temp[3]}`,
                                        `(${temp[0]}${ops[i]}(${temp[1]}${ops[j]}${temp[2]}))${ops[k]}${temp[3]}`,
                                        `${temp[0]}${ops[i]}((${temp[1]}${ops[j]}${temp[2]})${ops[k]}${temp[3]})`,
                                        `${temp[0]}${ops[i]}(${temp[1]}${ops[j]}(${temp[2]}${ops[k]}${temp[3]}))`,
                                        `(${temp[0]}${ops[i]}${temp[1]})${ops[j]}(${temp[2]}${ops[k]}${temp[3]})`
                                    ];
                                    
                                    for (const expr of expressions) {
                                        try {
                                            if (Math.abs(eval(expr) - 24) < 0.000001) {
                                                const normalized = normalizeExpression(expr);
                                                const key = getCanonicalKey(normalized);
                                                
                                                if (!seen.has(key)) {
                                                    seen.add(key);
                                                    solutions.add(normalized);
                                                }
                                            }
                                        } catch (e) {
                                            // 忽略除以零等错误
                                        }
                                    }
                                }
                            }
                        }
                        return;
                    }
                    
                    for (let i = 0; i < arr.length; i++) {
                        const curr = arr.slice();
                        const next = curr.splice(i, 1);
                        permute(curr.slice(), temp.concat(next));
                    }
                }
                
                permute(numbers);
                return Array.from(solutions).sort();
            }
            
            // 标准化表达式，去除不必要的括号
            function normalizeExpression(expr) {
                const tokens = tokenize(expr);
                const tree = parse(tokens);
                return formatTree(tree);
            }
            
            // 获取表达式的规范键，用于去除所有交换律导致的重复
            function getCanonicalKey(expr) {
                const tokens = tokenize(expr);
                const tree = parse(tokens);
                return canonicalizeTree(tree);
            }
            
            // 将表达式分解为标记
            function tokenize(expr) {
                const tokens = [];
                let current = '';
                
                for (const char of expr) {
                    if ('()+-*/'.includes(char)) {
                        if (current) {
                            tokens.push(current);
                            current = '';
                        }
                        tokens.push(char);
                    } else if (!isNaN(char) || char === '.') {
                        current += char;
                    }
                }
                
                if (current) {
                    tokens.push(current);
                }
                
                return tokens;
            }
            
            // 解析标记为语法树
            function parse(tokens) {
                const output = [];
                const operators = [];
                
                const precedence = {
                    '+': 1,
                    '-': 1,
                    '*': 2,
                    '/': 2
                };
                
                for (const token of tokens) {
                    if (!isNaN(token)) {
                        output.push({ type: 'number', value: parseFloat(token) });
                    } else if ('+-*/'.includes(token)) {
                        while (operators.length > 0 && 
                               operators[operators.length - 1] !== '(' &&
                               precedence[operators[operators.length - 1]] >= precedence[token]) {
                            output.push({ type: 'operator', value: operators.pop() });
                        }
                        operators.push(token);
                    } else if (token === '(') {
                        operators.push(token);
                    } else if (token === ')') {
                        while (operators.length > 0 && operators[operators.length - 1] !== '(') {
                            output.push({ type: 'operator', value: operators.pop() });
                        }
                        operators.pop(); // 弹出 '('
                    }
                }
                
                while (operators.length > 0) {
                    output.push({ type: 'operator', value: operators.pop() });
                }
                
                // 构建语法树
                const stack = [];
                for (const token of output) {
                    if (token.type === 'number') {
                        stack.push(token);
                    } else {
                        const right = stack.pop();
                        const left = stack.pop();
                        stack.push({
                            type: 'operation',
                            operator: token.value,
                            left,
                            right
                        });
                    }
                }
                
                return stack[0];
            }
            
            // 格式化语法树为表达式，去除不必要的括号
            function formatTree(node, parentPrec = 0) {
                if (node.type === 'number') {
                    return node.value.toString();
                }
                
                const precedence = {
                    '+': 1,
                    '-': 1,
                    '*': 2,
                    '/': 2
                };
                
                const currentPrec = precedence[node.operator];
                
                const leftStr = formatTree(node.left, currentPrec);
                const rightStr = formatTree(node.right, currentPrec + (node.operator === '-' || node.operator === '/' ? 1 : 0));
                
                let expr = '';
                
                // 处理左子表达式
                if (node.left.type === 'operation' && precedence[node.left.operator] < currentPrec) {
                    expr += `(${leftStr})`;
                } else {
                    expr += leftStr;
                }
                
                expr += node.operator;
                
                // 处理右子表达式
                if (node.right.type === 'operation' && 
                    (precedence[node.right.operator] < currentPrec || 
                     (node.operator === '-' && precedence[node.right.operator] <= currentPrec) ||
                     (node.operator === '/' && precedence[node.right.operator] <= currentPrec) ||
                     (node.operator === '*' && node.right.operator === '/') ||
                     (node.operator === '+' && node.right.operator === '-'))) {
                    expr += `(${rightStr})`;
                } else {
                    expr += rightStr;
                }
                
                if (currentPrec < parentPrec) {
                    return `(${expr})`;
                }
                
                return expr;
            }
            
            // 规范化语法树，去除所有交换律导致的重复
            function canonicalizeTree(node) {
                if (node.type === 'number') {
                    return node.value.toString();
                }
                
                const leftKey = canonicalizeTree(node.left);
                const rightKey = canonicalizeTree(node.right);
                
                // 对于可交换的运算符，统一顺序
                if (node.operator === '+' || node.operator === '*') {
                    const keys = [leftKey, rightKey].sort();
                    return `${node.operator}(${keys[0]},${keys[1]})`;
                }
                
                // 对于减法和除法，考虑特殊情况
                if (node.operator === '-') {
                    // a-(b-c) 与 (a-b)+c 可能等价
                    if (node.right.type === 'operation' && node.right.operator === '-') {
                        const a = leftKey;
                        const b = canonicalizeTree(node.right.left);
                        const c = canonicalizeTree(node.right.right);
                        const altKey = `+(${a}-${b},${c})`;
                        return `-(${a},-(${b},${c}))|${altKey}`;
                    }
                }
                
                if (node.operator === '/') {
                    // a/(b/c) 与 (a*c)/b 可能等价
                    if (node.right.type === 'operation' && node.right.operator === '/') {
                        const a = leftKey;
                        const b = canonicalizeTree(node.right.left);
                        const c = canonicalizeTree(node.right.right);
                        const altKey = `/(*(${a},${c}),${b})`;
                        return `/(${a},/(${b},${c}))|${altKey}`;
                    }
                }
                
                return `${node.operator}(${leftKey},${rightKey})`;
            }
        });
    </script>
</body>
</html>
